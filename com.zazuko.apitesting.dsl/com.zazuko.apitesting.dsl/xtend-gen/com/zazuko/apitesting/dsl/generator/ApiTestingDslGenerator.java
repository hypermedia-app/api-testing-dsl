/**
 * generated by Xtext 2.17.0
 */
package com.zazuko.apitesting.dsl.generator;

import com.google.common.collect.Iterators;
import com.zazuko.apitesting.dsl.apiTestingDsl.ClassBlock;
import com.zazuko.apitesting.dsl.apiTestingDsl.ClassLevelAssertion;
import com.zazuko.apitesting.dsl.apiTestingDsl.PropertyAssertion;
import java.util.Arrays;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.generator.AbstractGenerator;
import org.eclipse.xtext.generator.IFileSystemAccess2;
import org.eclipse.xtext.generator.IGeneratorContext;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.IteratorExtensions;

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
@SuppressWarnings("all")
public class ApiTestingDslGenerator extends AbstractGenerator {
  @Override
  public void doGenerate(final Resource resource, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
    final Iterable<ClassBlock> blocks = IteratorExtensions.<ClassBlock>toList(Iterators.<ClassBlock>filter(resource.getAllContents(), ClassBlock.class));
    boolean _isEmpty = IterableExtensions.isEmpty(blocks);
    boolean _not = (!_isEmpty);
    if (_not) {
      final String dslFileName = resource.getURI().lastSegment().toString();
      final String outFileBase = dslFileName.substring(0, dslFileName.lastIndexOf("."));
      fsa.generateFile((outFileBase + ".json"), this.generateSteps(blocks));
    }
  }
  
  public CharSequence generateSteps(final Iterable<ClassBlock> blocks) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("{");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("\"steps\": [");
    _builder.newLine();
    {
      boolean _hasElements = false;
      for(final ClassBlock block : blocks) {
        if (!_hasElements) {
          _hasElements = true;
        } else {
          _builder.appendImmediate(",", "\t\t");
        }
        _builder.append("\t\t");
        CharSequence _step = this.step(block);
        _builder.append(_step, "\t\t");
        _builder.newLineIfNotEmpty();
      }
    }
    _builder.append("\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    return _builder;
  }
  
  public CharSequence step(final ClassBlock it) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("{");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("\"type\": \"Class\",");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("\"classId\": \"");
    String _name = it.getName();
    _builder.append(_name, "\t");
    _builder.append("\",");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("\"children\": [");
    _builder.newLine();
    {
      EList<ClassLevelAssertion> _assertions = it.getAssertions();
      boolean _hasElements = false;
      for(final ClassLevelAssertion assertion : _assertions) {
        if (!_hasElements) {
          _hasElements = true;
        } else {
          _builder.appendImmediate(",", "\t\t");
        }
        _builder.append("\t\t");
        CharSequence _child = this.child(assertion);
        _builder.append(_child, "\t\t");
        _builder.newLineIfNotEmpty();
      }
    }
    _builder.append("\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    return _builder;
  }
  
  protected CharSequence _child(final PropertyAssertion it) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("{");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("\"type\": \"Property\",");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("\"propertyId\": \"");
    String _name = it.getName();
    _builder.append(_name, "\t");
    _builder.append("\",");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("\"children\": [");
    _builder.newLine();
    {
      EList<ClassLevelAssertion> _assertions = it.getAssertions();
      boolean _hasElements = false;
      for(final ClassLevelAssertion assertion : _assertions) {
        if (!_hasElements) {
          _hasElements = true;
        } else {
          _builder.appendImmediate(",", "\t\t");
        }
        _builder.append("\t\t");
        CharSequence _child = this.child(assertion);
        _builder.append(_child, "\t\t");
        _builder.newLineIfNotEmpty();
      }
    }
    _builder.append("\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    return _builder;
  }
  
  protected CharSequence _child(final ClassLevelAssertion it) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("# TODO: implementation missing for child(");
    String _name = it.getClass().getName();
    _builder.append(_name);
    _builder.append(")");
    _builder.newLineIfNotEmpty();
    return _builder;
  }
  
  public CharSequence child(final ClassLevelAssertion it) {
    if (it instanceof PropertyAssertion) {
      return _child((PropertyAssertion)it);
    } else if (it != null) {
      return _child(it);
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(it).toString());
    }
  }
}
